import sqlite3
import pandas as pd
from termcolor import colored
import subprocess
import shutil
import sys
MODULE_PATH = '/home/fredy/MisDocumentos/Diseno-de-Scripts/CADD_platform/drug_screening_package'
sys.path.append(MODULE_PATH)

from chemspace.general_procedures import blob_operations as blob_ops
from docking.docking_results_processing import process_docking_assay as dock_proc

def create_fingerprints_table(ml_models_path,receptor_models_registry_path,docking_assays_registry_path,reference_assay_nbr):
    """
    This function will create a table named 'positive_binders_fps' and 'negative_binders_fps' within a database 'interaction_fingerprints_data.db' located in the '$PATH/ml/ml_model_devel' path. 

    The structure of the table is:
        - fp_nbr: the fingerprint number as stored in the table
        - sub_pose: the name of the ligand subpose originating the stored interaction fingerprint.
        - assay_id: the docking assay id to which from which the fingerprint was extracted.
        - fingerprint_dict: the interaction fingerprint stored as a dictionary.
        - lig_pdb_file: the ligand pdb file originating the corresponding interaction fingerprint.
        - rec_pdb_file: the receptor pdb file to which the fingerprint was computed.
    
    ------
    Parameters:
    ------
    - ml_models_path: the full path where the ml stuff is stored within the project. Usually exported automatically from the environment setting.
    - receptor_models_registry_path: the full path to the folder in which docking receptors registries are stored. Generated by the automated setting of the environment.
    - docking_assays_registry_path: the full path to the folder in which docking assay registries are stored. Generated by the automated setting of the environment.

    ------
    Returns
    ------
    A table that is used to store all interaction fingerprints intender for ml analysis.
    """

    try: 
        conn = sqlite3.connect(f'{ml_models_path}/ml_model_devel/interaction_fingerprints_data.db')

        ins = f'CREATE TABLE positive_binders ("fp_nbr" INTEGER, "sub_pose" TEXT, "assay_id" INTEGER, "fingerprint_dict" TEXT, lig_pdb_file TEXT, rec_pdb_file TEXT)'
        conn.execute(ins)
        ins = f'CREATE TABLE negative_binders ("fp_nbr" INTEGER,"sub_pose" TEXT, "assay_id" INTEGER, "fingerprint_dict" TEXT, lig_pdb_file TEXT, rec_pdb_file TEXT)'
        conn.execute(ins)
        print(colored("Interaction fingerprints table created.","green"))
        
        # Store a dummy record modeling the whole receptor residues
        create_dummy_fingerprint_record(ml_models_path,receptor_models_registry_path,docking_assays_registry_path,reference_assay_nbr)
        

    except Exception as error:
        print(error)
        print(colored("Error creating the Interaction fingerprints table.","red"))

def create_dummy_fingerprint_record(ml_models_path,receptor_models_registry_path,docking_assays_registry_path,reference_assay_nbr):
    """
    This function will create an exmpty (dummy) fingerprint record with all the receptor columns generated to guarantee a fingerprint consistency
    ------
    Parameters:
    ------
    - receptor_models_registry_path: the full path to the folder in which docking receptors registries are stored. Generated by the automated setting of the environment.
    - docking_assays_registry_path: the full path to the folder in which docking assay registries are stored. Generated by the automated setting of the environment.
    """

    ### In this section we will create a list with the Interaction fingerprints  column names for the WHOLE PROTEIN

    plf_receptor = dock_proc.create_receptor_mda_object(receptor_models_registry_path,docking_assays_registry_path,reference_assay_nbr)

    # get a list of residue names and numbers
    protein_residues_crystal = list(plf_receptor.residues)
    my_list = [str(i) for i in protein_residues_crystal]
    aa_name_list = []
    aa_nbr_list = []
    cristal_sequence = [] 

    for item in my_list:
        #striped_item = item.split()
        #aa_name_list.append(striped_item[1].replace(',',''))
        #aa_nbr_list.append(striped_item[2].replace('>',''))
        #cristal_sequence.append(striped_item[1].replace(',','') + striped_item[2].replace('>',''))
        cristal_sequence.append(item)
    
    # This will enumerate all the dataframe column names based on the crystal sequence and the interaction types.
    crystal_columns_name_list = []
    interaction_types = ['Anionic','CationPi','Cationic','EdgeToFace','FaceToFace','HBAcceptor','HBDonor','Hydrophobic','MetalAcceptor','MetalDonor','PiCation','PiStacking','VdWContact','XBAcceptor','XBDonor']
    dummy_values_list = []
    for residue in cristal_sequence:
        for int_type in interaction_types:
            crystal_columns_name_list.append(residue + '-' + int_type)
            dummy_values_list.append(0)

    # create and empty dataframe with the column names for the final concat operation
    df_complete_columns = pd.DataFrame([dummy_values_list],columns = crystal_columns_name_list)
    
    #df_complete_columns["binder"] = 1
    fingerprint_dict = df_complete_columns.T.to_dict()[0]

    ## Store the dummy fingerprint into the corresponding database and tables.
    # On possitive binders table
    conn = sqlite3.connect(f'{ml_models_path}/ml_model_devel/interaction_fingerprints_data.db')
    sql1 = f"""INSERT INTO positive_binders (fp_nbr, sub_pose, assay_id, fingerprint_dict, lig_pdb_file,rec_pdb_file) VALUES (0,"DUMMY",0,"{fingerprint_dict}","DUMMY","DUMMY");"""             
    conn.execute(sql1)
    conn.commit()
    # On negative binders table
    sql2 = f"""INSERT INTO negative_binders (fp_nbr, sub_pose, assay_id, fingerprint_dict, lig_pdb_file,rec_pdb_file) VALUES (0,"DUMMY",0,"{fingerprint_dict}","DUMMY","DUMMY");"""             
    conn.execute(sql2)
    conn.commit()

    print(colored(f"Succesfully created table a dummy record","green"))

def store_positive_fingerprint(ml_models_path,receptor_models_registry_path,docking_assays_registry_path,docking_assays_storing_path,assay_nbr,sub_pose,pdb_folder_name):
    """
    This function will retrieve an interaction fingerprint as calculated by ProLIF and stored in a certain docking assay.

    The fingerprint will be stored as a dictionary in a database named 'interaction_fingerprints_data.db' stored in the '$PATH/ml/ml_model_devel' path.

    This positive fingerprints will be stored in a table named, "positive_binders".

    A column named 'binder' containing a value = 1 will be added.
    ------
    Parameters:
    ------
    - ml_models_path: the full path generated for storing ml stuff within the project. Generated by the automated setting of the environment.
    - receptor_models_registry_path: the full path to the folder in which docking receptors registries are stored. Generated by the automated setting of the environment.
    - docking_assays_registry_path: the full path to the folder in which docking assay registries are stored. Generated by the automated setting of the environment.
    - docking_assays_storing_path: the full path to the folder in which docking assays are stored. Generated by the automated setting of the environment.
    - assay_nbr: the number of the docking assay containing the fingerprint to be extracted. This assays must containg the corresponding analysis database
    - sub_pose: the name of the ligand pose originating the fingerprint to be extracted. This is an inchi key value followed by a subpose subindex.
    - pdb_folder_name: The name of the folder from which the pdb file corresponding to the stored fingerprint is located.

    
    ------
    Returns:
    ------
    A single interaction fingerprint is stored to the 'positive_binders' table within the 'interaction_fingerprints_data.db' stored in the '$PATH/ml/ml_model_devel' path.
    """

    try:
        # Check if identical fingerprint (same assay and subpose) has already been stored.
        exists = check_fp_existence(ml_models_path,assay_nbr,sub_pose,"positive_binders")

        if exists == 1:
            print(colored(f"The sub_pose {sub_pose}; assay: {assay_nbr} is already stored. Exit.","red"))
            exit()
        
        # Retrieve the fingerprint record from the corresponding docking assay database 
        
        assay_path = f'{docking_assays_storing_path}/docking_assay_{assay_nbr}'
        database_file = f'{assay_path}/docking_assay_{assay_nbr}.db'

        conn = sqlite3.connect(database_file)
        sql = f"""SELECT *
                 FROM prolif_interactions
                 WHERE sub_pose= '{sub_pose}'"""
        
        df = pd.read_sql_query(sql,conn)
        sub_pose = df["sub_pose"][0]
        df.drop(["sub_pose"],inplace=True,axis=1)
        df["binder"] = 1
        fingerprint_dict = df.T.to_dict()[0]
        conn.close()

        # Retrieve the ligand .pdb filename
        lig_pdb_file = f'{sub_pose}.pdb'
        ligand_filename = f'{docking_assays_storing_path}/docking_assay_{assay_nbr}/{pdb_folder_name}/{lig_pdb_file}'
        
        ## Actions to retrieve the .pdb files used for the ProLIF analysis
        # Get the receptor model id from the docking assay registry
        conn = sqlite3.connect(f'{docking_assays_registry_path}/docking_registries.db')
        sql = f"""SELECT rec_model_id
                 FROM docking_registries
                 WHERE assay_id = {assay_nbr};"""
        df = pd.read_sql_query(sql,conn)
        rec_model_id = df["rec_model_id"][0]
        
        conn.close()

        # Get the .pdb file for the given rec_model_id
        conn = sqlite3.connect(f'{receptor_models_registry_path}/receptors_models_registry.db')
        sql = f"""SELECT pdb_file
                 FROM receptor_models
                 WHERE rec_model_id = {rec_model_id};"""
        df = pd.read_sql_query(sql,conn)
        rec_pdb_file = df["pdb_file"][0]
        conn.close()

        # Get the las fp_nbr present in the table
        last_fp_nbr = get_last_fp_number(ml_models_path,"positive_binders")
        curr_fp_nbr = last_fp_nbr+1
        
        # Store the info to the destination database
        conn = sqlite3.connect(f'{ml_models_path}/ml_model_devel/interaction_fingerprints_data.db')
        sql = f"""INSERT INTO positive_binders (fp_nbr, sub_pose, assay_id, fingerprint_dict, lig_pdb_file,rec_pdb_file) VALUES ({curr_fp_nbr},"{sub_pose}",{assay_nbr},"{fingerprint_dict}","{ligand_filename}","{rec_pdb_file}");"""             
        conn.execute(sql)
        conn.commit()
        print(colored(f"Interaction fingerprint for sub_pose: {sub_pose} successfully stored as positive binder","green"))

        # Retrieve, process and store the pdb files corresponding to this fingerprint
        store_fingerprint_ligand_pdb_file(ml_models_path,ligand_filename,curr_fp_nbr,"positive_binders")
        store_fingerprint_receptor_pdb_file(ml_models_path,rec_pdb_file)

    except Exception as error:
        print(error)
        print(colored(f"Error storing the fingerprint id: {assay_nbr} as positive binder.","red"))

def store_negative_fingerprint(ml_models_path,receptor_models_registry_path,docking_assays_registry_path,docking_assays_storing_path,assay_nbr,sub_pose,pdb_folder_name):
    """
    This function will retrieve an interaction fingerprint as calculated by ProLIF and stored in a certain docking assay.

    The fingerprint will be stored as a dictionary in a database named 'interaction_fingerprints_data.db' stored in the '$PATH/ml/ml_model_devel' path.

    This negative fingerprints will be stored in a table named, "negative_binders".

    A column named 'binder' containing a value = 0 will be added.
    ------
    Parameters:
    ------
    - ml_models_path: the full path generated for storing ml stuff within the project. Generated by the automated setting of the environment.
    - receptor_models_registry_path: the full path to the folder in which docking receptors registries are stored. Generated by the automated setting of the environment.
    - docking_assays_registry_path: the full path to the folder in which docking assay registries are stored. Generated by the automated setting of the environment.
    - docking_assays_storing_path: the full path to the folder in which docking assays are stored. Generated by the automated setting of the environment.
    - assay_nbr: the number of the docking assay containing the fingerprint to be extracted. This assays must containg the corresponding analysis database
    - sub_pose: the name of the ligand pose originating the fingerprint to be extracted. This is an inchi key value followed by a subpose subindex.
    - pdb_folder_name: The name of the folder from which the pdb file corresponding to the stored fingerprint is located.
    
    ------
    Returns:
    ------
    A single interaction fingerprint is stored to the 'negative_binders' table within the 'interaction_fingerprints_data.db' stored in the '$PATH/ml/ml_model_devel' path.
    """

    try:
        # Check if identical fingerprint (same assay and subpose) has already been stored.
        exists = check_fp_existence(ml_models_path,assay_nbr,sub_pose,"negative_binders")

        if exists == 1:
            print(colored(f"The sub_pose {sub_pose}; assay: {assay_nbr} is already stored. Exit.","red"))
            exit()
        
        # Retrieve the fingerprint record from the corresponding docking assay database 
        
        assay_path = f'{docking_assays_storing_path}/docking_assay_{assay_nbr}'
        database_file = f'{assay_path}/docking_assay_{assay_nbr}.db'

        conn = sqlite3.connect(database_file)
        sql = f"""SELECT *
                 FROM prolif_interactions
                 WHERE sub_pose= '{sub_pose}'"""
        
        df = pd.read_sql_query(sql,conn)
        sub_pose = df["sub_pose"][0]
        df.drop(["sub_pose"],inplace=True,axis=1)
        df["binder"] = 0
        fingerprint_dict = df.T.to_dict()[0]
        conn.close()

        # Create the ligand .pdb filename
        lig_pdb_file = f'{sub_pose}.pdb'
        ligand_filename = f'{docking_assays_storing_path}/docking_assay_{assay_nbr}/{pdb_folder_name}/{lig_pdb_file}'
        
        ## Actions to retrieve the .pdb files used for the ProLIF analysis
        # Get the receptor model id from the docking assay registry
        conn = sqlite3.connect(f'{docking_assays_registry_path}/docking_registries.db')
        sql = f"""SELECT rec_model_id
                 FROM docking_registries
                 WHERE assay_id = {assay_nbr};"""
        df = pd.read_sql_query(sql,conn)
        rec_model_id = df["rec_model_id"][0]
        
        conn.close()

        # Get the .pdb file for the given rec_model_id
        conn = sqlite3.connect(f'{receptor_models_registry_path}/receptors_models_registry.db')
        sql = f"""SELECT pdb_file
                 FROM receptor_models
                 WHERE rec_model_id = {rec_model_id};"""
        df = pd.read_sql_query(sql,conn)
        rec_pdb_file = df["pdb_file"][0]
        conn.close()

        # Get the las fp_nbr present in the table
        last_fp_nbr = get_last_fp_number(ml_models_path,"negative_binders")
        curr_fp_nbr = last_fp_nbr+1
        # Store the info to the destination database
        conn = sqlite3.connect(f'{ml_models_path}/ml_model_devel/interaction_fingerprints_data.db')
        sql = f"""INSERT INTO negative_binders (fp_nbr, sub_pose, assay_id, fingerprint_dict, lig_pdb_file,rec_pdb_file) VALUES ({curr_fp_nbr},"{sub_pose}",{assay_nbr},"{fingerprint_dict}","{ligand_filename}","{rec_pdb_file}");"""             
        conn.execute(sql)
        conn.commit()
        print(colored(f"Interaction fingerprint for sub_pose: {sub_pose} successfully stored as negative binder","green"))

        # Retrieve, process and store the pdb files corresponding to this fingerprint
        store_fingerprint_ligand_pdb_file(ml_models_path,ligand_filename,curr_fp_nbr,"negative_binders")
        store_fingerprint_receptor_pdb_file(ml_models_path,rec_pdb_file)

    except Exception as error:
        print(error)
        print(colored(f"Error storing the fingerprint id: {assay_nbr} as negative binder.","red"))

def compute_and_store_selected_fingerprint(receptor_models_registry_path,docking_assays_registry_path,docking_raw_data_path,docking_assays_storing_path,ml_models_path,assay_nbr,table_name,sub_pose,classification):

    """
    This function will run a two step processing:

        - the computation of a single prolif interaction fingerprint.
        - the storage of the corresponding fingerprint to the correspongin classification table.

    """

    dock_proc.compute_selected_prolif_interaction_patterns(receptor_models_registry_path,docking_assays_registry_path,docking_raw_data_path,assay_nbr,table_name,sub_pose)

    pdb_folder_name = "selected_docked_ligands"

    if classification == "positive":
        store_positive_fingerprint(ml_models_path,receptor_models_registry_path,docking_assays_registry_path,docking_assays_storing_path,assay_nbr,sub_pose,pdb_folder_name)
    
    elif classification == "negative":
        store_negative_fingerprint(ml_models_path,receptor_models_registry_path,docking_assays_registry_path,docking_assays_storing_path,assay_nbr,sub_pose,pdb_folder_name)

    else:
        print(colored("Error providing the classification of the fingerprint (positive/negative).","red"))
        exit()
              
def get_last_fp_number(ml_models_path,table_name):
    """
    This function will return the value of the last fingerprint stored within the table
    """
    conn = sqlite3.connect(f'{ml_models_path}/ml_model_devel/interaction_fingerprints_data.db')

    sql = f"""SELECT fp_nbr 
                   FROM {table_name};"""

    try:     
        df = pd.read_sql_query(sql,conn)
        model_id_list = df["fp_nbr"].to_list()
        if len(model_id_list) == 0: # This will hit in case no previous record in the table is present
            return 0
        else:
            last_value = model_id_list[-1]
            return last_value

    except Exception as error:
        print(error)
        print(colored("Error retrieving the last fingerprint number ID value","red"))

def store_fingerprint_ligand_pdb_file(ml_models_path,file,fp_nbr,binder_type_folder):
    """
    This function will retrieve a pdb file corresponding to an extracted computed fingerprint, and will store it within the folders corresponding to the fingerprints storage
    """
    storage_folder = f'{ml_models_path}/misc/{binder_type_folder}'
    # Process the file full path in order to include the 'fp_nrb' suffix.
    file_prefix = file.split('/')[-1].strip('.pdb')
    output_file = f'{storage_folder}/{file_prefix}_{fp_nbr}.pdb'
    shutil.copyfile(file,output_file)    

def store_fingerprint_receptor_pdb_file(ml_models_path,file):
    """
    This function will retrieve a pdb file corresponding to the receptor used to compute a fingerprint, and will store it within the folders corresponding to the fingerprints storage.

    If the target file already exists, it will be replaced.

    ------
    Parameters:
    ------
    - ml_models_path: the full path generated for storing ml stuff within the project. Generated by the automated setting of the environment.
    - file: the full path to the receptor file to be copied to the storage folder.
    """
    storage_folder = f'{ml_models_path}/misc/receptors'
    # Process the file full path in order to include the 'fp_nrb' suffix.
    file_name = file.split('/')[-1]
    output_file = f'{storage_folder}/{file_name}'
    shutil.copyfile(file,output_file)

def check_fp_existence(ml_models_path,assay_nbr,sub_pose,table):
    """
    This function will check if a certain fingerprint 
    """

    # Connect to the existing database
    conn = sqlite3.connect(f'{ml_models_path}/ml_model_devel/interaction_fingerprints_data.db')
    sql = f"""SELECT sub_pose, assay_id
              FROM {table};"""
    
    df = pd.read_sql_query(sql,conn)
    sub_pose_list = df["sub_pose"].to_list()
    assay_id_list = df["assay_id"].to_list()

    if sub_pose in sub_pose_list and assay_nbr in assay_id_list:
        return 1
    else:
        return 0

def construct_overall_fingerprints_file(ml_models_path):

    """
    This function will prepare a .csv file containing all the interaction fingerprints corresponding to the stored positive and negative binders.

    ------
    Parameters:
    ------
    - ml_models_path: the full path generated for storing ml stuff within the project. Generated by the automated setting of the environment.

    ------
    Returns:
    ------
    A .csv fiel stored in the '${ml_models_path}/misc/fingerprint_csv_files' folder.

    """

    figerprints_db = f'{ml_models_path}/ml_model_devel/interaction_fingerprints_data.db'

    conn = sqlite3.connect(figerprints_db)
    sql_positives = """SELECT *
                    FROM positive_binders;"""
    df_positives = pd.read_sql_query(sql_positives,conn)

    counter = 1
    whole_df = pd.DataFrame()
    
    # Append data corresponding to negative binders
    for index, row in df_positives.iterrows():
        sub_pose = row['sub_pose']
        fps = eval(row['fingerprint_dict']) # This will return a dictionary for the fingerprint
        single_df = pd.DataFrame(fps,index=['i',])
        single_df.insert(loc=0,column='pose_name',value=sub_pose)
        single_df.insert(loc=1,column='binder_class',value=1)
        if counter == 1:
            whole_df = single_df
            counter+=1
        else:
            whole_df = pd.concat([whole_df,single_df], ignore_index=True, sort=False)

    sql_negatives = """SELECT *
                    FROM negative_binders;"""
    df_negatives = pd.read_sql_query(sql_negatives,conn)

    # Append data corresponding to negative binders
    for index, row in df_negatives.iterrows():
        sub_pose = row['sub_pose']
        fps = eval(row['fingerprint_dict']) # This will return a dictionary for the fingerprint
        single_df = pd.DataFrame(fps,index=['i',])
        single_df.insert(loc=0,column='pose_name',value=sub_pose)
        single_df.insert(loc=1,column='binder_class',value=0)
        whole_df = pd.concat([whole_df,single_df], ignore_index=True, sort=False)

    # Fill all NaN values with 0: corresponds to ligands not contacting resides
    whole_df_complete = whole_df.fillna(0)

    # Drop a column named 'binder' that was stored in the original fingerprint
    whole_df_complete = whole_df_complete.drop('binder', axis=1)

    # Delete the dummy record in the database
    whole_df_complete = whole_df_complete[whole_df_complete["pose_name"].str.contains("DUMMY") == False]

    # Write the corresponding data to a .csv file
    file_name = input("Provide the name for the fingerprints .csv file: ") 

    whole_df_complete.to_csv(f'{ml_models_path}/misc/fingerprint_csv_files/{file_name}', index=False)

### Section to test functions 
    
if __name__ == "__main__":

    print("Write test function")

    #create_fingerprints_table("/home/fredy/MisDocumentos/Diseno-de-Scripts/CADD_platform/TEST/ml")

    #store_positive_fingerprint("/home/fredy/MisDocumentos/Diseno-de-Scripts/CADD_platform/TEST/ml","/home/fredy/MisDocumentos/Diseno-de-Scripts/CADD_platform/TEST/docking/receptor_models_registers","/home/fredy/MisDocumentos/Diseno-de-Scripts/CADD_platform/TEST/docking/docking_assays_registers","/home/fredy/MisDocumentos/Diseno-de-Scripts/CADD_platform/TEST/docking/docking_assays",1,"LIENCHBZNNMNKG-OJFNHCPVSA-N_1")
    
    #store_negative_fingerprint("/home/fredy/MisDocumentos/Diseno-de-Scripts/CADD_platform/TEST/ml","/home/fredy/MisDocumentos/Diseno-de-Scripts/CADD_platform/TEST/docking/receptor_models_registers","/home/fredy/MisDocumentos/Diseno-de-Scripts/CADD_platform/TEST/docking/docking_assays_registers","/home/fredy/MisDocumentos/Diseno-de-Scripts/CADD_platform/TEST/docking/docking_assays",1,"LIENCHBZNNMNKG-OJFNHCPVSA-N_1")





